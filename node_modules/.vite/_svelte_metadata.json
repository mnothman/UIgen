{"compilerOptions":{"css":"external","dev":true},"extensions":[".svelte"],"preprocess":[{"markup":"markup({ content }) {\n          return { code: apply_repls(content, markup_repls) };\n        }"},{"markup":"async ({ content, filename }) => {\n    let code = content;\n\n    // NOTE don't try to parse <style>\n    // there's nothing for us to be found in there, and it breaks with style\n    // preprocessors\n    // see: https://github.com/rixo/svelte-preprocess-autoimport/issues/2\n    const ast = compiler.parse(trimStyle(content));\n\n    const found = new Set();\n    const excluded = {};\n\n    const dispatches = [];\n\n    compiler.walk(ast, {\n      enter(node, parent) {\n        switch (node.type) {\n          case 'Transition': // #4\n          case 'Animation':\n          case 'Identifier': {\n            const { name } = node;\n            if (excluded[name]) break\n            if (isDeclaration(node, parent)) {\n              excluded[name] = true;\n              break\n            }\n            if (createEventDispatcher && createEventDispatcher === name) {\n              dispatches.push(node);\n              break\n            }\n            if (aliases[name]) found.add(name);\n            break\n          }\n        }\n      },\n    });\n\n    const statements = [];\n\n    const grouped = {};\n\n    if (dispatches.length > 0) {\n      grouped['svelte'] = [\n        'createEventDispatcher as ___spài_createEventDispatcher',\n      ];\n      const targetName = createEventDispatcher.replace(/^(\\$+)/, a =>\n        '_'.repeat(a.length)\n      );\n      for (const { start, end, name } of dispatches) {\n        code = code.slice(0, start) + targetName + code.slice(end);\n      }\n      statements.push(`const ${targetName} = ___spài_createEventDispatcher()`);\n    }\n\n    // aliases\n    if (found.size > 0) {\n      for (const alias of found) {\n        const { from, import: name, as } = parseAlias(aliases[alias], alias);\n        if (!grouped[from]) grouped[from] = [];\n        grouped[from].push(name === as ? name : `${name} as ${as}`);\n      }\n    }\n\n    if (Object.keys(grouped).length > 0) {\n      statements.unshift(\n        Object.entries(grouped)\n          .map(\n            ([from, names]) =>\n              `import { ${names.sort().join(', ')} } from '${from}'`\n          )\n          .join('; ')\n      );\n    }\n\n    if (statements.length > 0) {\n      const target = ast.instance;\n\n      const line = statements.join('; ') + ';';\n\n      if (target) {\n        code =\n          code.slice(0, target.content.start) +\n          line +\n          code.slice(target.content.start);\n      } else {\n        code = code + `\\n<script>${line}</script>`;\n      }\n    }\n\n    return { code, map: null }\n  }"},{"markup":"async ({ content, filename }) => {\n        if (transformers.replace) {\n            const transformed = await (0, exports.transform)('replace', transformers.replace, {\n                content,\n                markup: content,\n                filename,\n            });\n            content = transformed.code;\n        }\n        return (0, markup_1.transformMarkup)({ content, filename }, markupTransformer, {\n            // we only pass the markupTagName because the rest of options\n            // is fetched internally by the `markupTransformer`\n            markupTagName,\n        });\n    }","script":"async ({ content, attributes, markup: fullMarkup, filename, }) => {\n        const transformResult = await scriptTransformer({\n            content,\n            attributes,\n            markup: fullMarkup,\n            filename,\n        });\n        let { code, map, dependencies, diagnostics } = transformResult;\n        if (transformers.babel) {\n            const transformed = await (0, exports.transform)('babel', getTransformerOptions('babel'), { content: code, markup: fullMarkup, map, filename, attributes });\n            code = transformed.code;\n            map = transformed.map;\n            dependencies = (0, utils_1.concat)(dependencies, transformed.dependencies);\n            diagnostics = (0, utils_1.concat)(diagnostics, transformed.diagnostics);\n        }\n        return { code, map, dependencies, diagnostics };\n    }","style":"async ({ content, attributes, markup: fullMarkup, filename, }) => {\n        const transformResult = await cssTransformer({\n            content,\n            attributes,\n            markup: fullMarkup,\n            filename,\n        });\n        let { code, map, dependencies } = transformResult;\n        const hasPostcss = await (0, utils_1.hasDepInstalled)('postcss');\n        // istanbul ignore else\n        if (hasPostcss) {\n            if (transformers.postcss) {\n                const { alias, lang } = (0, language_1.getLanguage)(attributes);\n                const postcssOptions = getTransformerOptions('postcss', (0, language_1.isAliasOf)(alias, lang) ? alias : null, \n                // todo: this seems wrong and ugly\n                { ignoreAliasOverride: true });\n                const transformed = await (0, exports.transform)('postcss', postcssOptions, {\n                    content: code,\n                    markup: fullMarkup,\n                    map,\n                    filename,\n                    attributes,\n                });\n                code = transformed.code;\n                map = transformed.map;\n                dependencies = (0, utils_1.concat)(dependencies, transformed.dependencies);\n            }\n            const transformed = await (0, exports.transform)('globalStyle', getTransformerOptions('globalStyle'), { content: code, markup: fullMarkup, map, filename, attributes });\n            code = transformed.code;\n            map = transformed.map;\n        }\n        else if ('global' in attributes) {\n            console.warn(`[svelte-preprocess] 'global' attribute found, but 'postcss' is not installed. 'postcss' is used to walk through the CSS and transform any necessary selector.`);\n        }\n        return { code, map, dependencies };\n    }"}]}